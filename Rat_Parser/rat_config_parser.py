from argparse import ArgumentParser
from concurrent.futures import ProcessPoolExecutor
from config_parser import RATConfigParser
from itertools import repeat
from json import dumps
from logging import basicConfig, DEBUG, getLogger, WARNING
from pathlib import Path
from yara import load
from yara_rules.recompile import recompile

logger = getLogger(__name__)

YARC_PATH = "yara_rules/rules.yarc"
YARA_RECOMPILE_PATH = "yara_rules/recompile.py"

def load_yara(compiled_rule_path):
    try:
        return load(compiled_rule_path)
    except Exception as e:
        raise Exception(f"Erro ao rodar regra") from e
    
def parse_args():
    ap = ArgumentParser()
    ap.add_argument("file_paths", nargs="+",help="Uma ou mais payload",)
    ap.add_argument("-d", "--debug", action="store_true", help="Ativar debug",)
    ap.add_argument("-r", "--recompile", action="store_true", help="recompila a regra Yara",)
    ap.add_argument("-y","--yara",default=str(Path(__file__).parent/YARC_PATH),help="Identifica a possivel familia de RAT",)
    return ap.parse_args()

def parse_config(fp,debug,yara_rule_path):
    basicConfig(level=DEBUG if debug else WARNING)
    rule = load_yara(yara_rule_path)
    return RATConfigParser(fp,rule).report

if __name__ == "__main__":
    parsed_args = parse_args()
    if parsed_args.recompile:
        recompile()
    decrypted_configs, result = [], []

    with ProcessPoolExecutor() as executor:
        results = execultor.map(
            parse_config,
            parsed_args.file_paths,
            repeat(parse_args.debug),
            repeat(parse_args.yara),
        )

    decrypted_configs.extend(results)
    if len(decrypted_configs) >0:
        print(dumps(decrypted_configs))